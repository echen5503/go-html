<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Go Game — Vanilla HTML</title>
  <style>
    :root{
      --bg:#0b0c10; --panel:#15171d; --muted:#cfd6e6; --text:#e8ecf5; --accent:#10b981;
      --board:#e6c799; --grid:#222; --black:#111; --white:#eee;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial}
    .container{max-width:1200px;margin:0 auto;padding:20px}
    .grid{display:grid;grid-template-columns:1fr 360px;gap:16px}
    @media (max-width: 1000px){.grid{grid-template-columns:1fr}}
    .card{background:var(--panel);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.25);padding:16px}
    .title{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
    .title h1{font-size:18px;margin:0}
    .subtitle{opacity:.8;font-size:13px}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:10px;align-items:center}
    label{font-size:13px;opacity:.8}
    select,input[type=number]{width:100%;background:#0e1116;color:var(--text);border:1px solid #222;border-radius:10px;padding:8px}
    button{background:#1b1f2a;border:1px solid #232838;color:var(--text);padding:8px 12px;border-radius:10px;cursor:pointer}
    button:hover{background:#232838}
    button.primary{background:var(--accent);border:1px solid #0b9b70;color:#05261c;font-weight:700}
    button.danger{background:#b91c1c;border-color:#991b1b}
    .btns{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px}
    .status{margin-top:10px;opacity:.9;font-size:13px}
    .score-grid{display:grid;grid-template-columns:1fr 1fr;gap:6px;font-size:14px}
    .small{opacity:.8}
    svg{display:block;border-radius:12px;background:var(--board)}
    .note{font-size:12px;opacity:.85}
    .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;background:#10131a;border:1px solid #202735;padding:0 6px;border-radius:6px}
  </style>
</head>
<body>
<div class="container">
  <div class="grid">
    <div class="card">
      <div class="title">
        <h1>Go — <span id="sizeLabel">19×19</span></h1>
        <div class="subtitle">Turn: <span id="turnLabel">Black</span></div>
      </div>
      <svg id="board" width="760" height="760" aria-label="Go Board"></svg>
      <div class="btns">
        <button id="undoBtn">Undo</button>
        <button id="redoBtn">Redo</button>
        <button id="passBtn">Pass</button>
        <button id="resignBtn" class="danger">Resign</button>
        <button id="exportBtn">Export SGF</button>
      </div>
      <div id="status" class="status"></div>
    </div>

    <div class="card">
      <div class="title"><h1>New Game</h1></div>
      <div class="row">
        <label for="sizeSel">Board size</label>
        <select id="sizeSel">
          <option value="9">9×9</option>
          <option value="13">13×13</option>
          <option value="19" selected>19×19</option>
        </select>

        <label for="handicapSel">Handicap (Black)</label>
        <select id="handicapSel"></select>

        <label for="komiInp">Komi (White)</label>
        <input id="komiInp" type="number" step="0.5" value="6.5" />
      </div>
      <div class="btns">
        <button id="newBtn" class="primary">Start / Reset</button>
      </div>

      <div class="title" style="margin-top:14px"><h1>Status</h1></div>
      <div class="score-grid" id="scoreGrid"></div>

      <div class="title" style="margin-top:14px"><h1>Notes</h1></div>
      <ul class="note">
        <li>Handicap stones are placed on standard star points; after that, White moves first.</li>
        <li>Simple <b>ko</b> is enforced (no immediate exact board repetition).</li>
        <li>Suicide is illegal unless it captures opponent stones.</li>
        <li>Pass twice in a row to finish and compare the estimated area score.</li>
        <li>Tip: press <span class="kbd">U</span> to undo, <span class="kbd">R</span> to redo, <span class="kbd">P</span> to pass.</li>
      </ul>
    </div>
  </div>
</div>

<script>
(() => {
  const BLACK = 1, WHITE = -1;
  const boardSVG = document.getElementById('board');
  const sizeSel = document.getElementById('sizeSel');
  const handicapSel = document.getElementById('handicapSel');
  const komiInp = document.getElementById('komiInp');
  const newBtn = document.getElementById('newBtn');
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const passBtn = document.getElementById('passBtn');
  const resignBtn = document.getElementById('resignBtn');
  const exportBtn = document.getElementById('exportBtn');
  const sizeLabel = document.getElementById('sizeLabel');
  const turnLabel = document.getElementById('turnLabel');
  const scoreGrid = document.getElementById('scoreGrid');
  const statusEl = document.getElementById('status');

  // Board rendering metrics
  let size = 19; // default
  let komi = 6.5;
  let handicap = 0;
  const cellPx = 36;
  const origin = 20;

  function emptyBoard(n){ return Array.from({length:n}, () => Array(n).fill(0)); }
  function deepCloneBoard(b){ return b.map(r => r.slice()); }
  function serializeBoard(b){ return b.map(r => r.join(',')).join('\n'); }
  function opposite(c){ return -c; }
  function neighbors(n,r,c){ const a=[]; if(r>0)a.push([r-1,c]); if(r<n-1)a.push([r+1,c]); if(c>0)a.push([r,c-1]); if(c<n-1)a.push([r,c+1]); return a; }

  function getGroupAndLiberties(board,n,r,c){
    const color = board[r][c];
    if(color===0) return {stones:new Set(), liberties:new Set()};
    const key = (r,c)=>`${r},${c}`;
    const visited=new Set(), stones=new Set(), liberties=new Set();
    const st=[[r,c]];
    while(st.length){
      const [rr,cc]=st.pop(); const k=key(rr,cc); if(visited.has(k)) continue; visited.add(k); stones.add(k);
      for(const [nr,nc] of neighbors(n,rr,cc)){
        const v=board[nr][nc];
        if(v===0) liberties.add(key(nr,nc));
        else if(v===color){ const kk=key(nr,nc); if(!visited.has(kk)) st.push([nr,nc]); }
      }
    }
    return {stones, liberties};
  }

  function starPoints(n){
    const pts=[]; let hs;
    if(n===19) hs=[3,9,15]; else if(n===13) hs=[3,6,9]; else if(n===9) hs=[2,4,6]; else return pts;
    for(const r of hs){ for(const c of hs){ pts.push([r,c]); } }
    const [lo,mid,hi] = (n===19)?[3,9,15]:(n===13)?[3,6,9]:[2,4,6];
    const seq=[[lo,lo],[hi,hi],[lo,hi],[hi,lo],[lo,mid],[hi,mid],[mid,lo],[mid,hi],[mid,mid]];
    return seq.filter(([r,c]) => pts.some(([rr,cc])=>rr===r && cc===c));
  }

  function placeHandicap(board,n,count){
    const pts = starPoints(n).slice(0, Math.max(0, Math.min(count, 9)));
    const out = deepCloneBoard(board);
    for(const [r,c] of pts) out[r][c]=BLACK;
    return out;
  }

  function attemptPlay(board,n,r,c,color,prevBoardStr){
    if(board[r][c]!==0) return {ok:false, reason:'occupied'};
    const working = deepCloneBoard(board);
    working[r][c]=color;
    const opp = opposite(color);
    let capturedCount=0; const toRemove=new Set();

    const key=(rr,cc)=>`${rr},${cc}`;
    for(const [nr,nc] of neighbors(n,r,c)){
      if(working[nr][nc]===opp){
        const {stones, liberties} = getGroupAndLiberties(working,n,nr,nc);
        if(liberties.size===0){ for(const s of stones) toRemove.add(s); }
      }
    }
    if(toRemove.size){ for(const s of toRemove){ const [rr,cc]=s.split(',').map(Number); working[rr][cc]=0; } capturedCount=toRemove.size; }

    const {liberties:myLibs} = getGroupAndLiberties(working,n,r,c);
    if(myLibs.size===0 && capturedCount===0) return {ok:false, reason:'suicide'};

    const newStr = serializeBoard(working);
    if(prevBoardStr && newStr===prevBoardStr) return {ok:false, reason:'ko'};

    return {ok:true, board:working, captured:capturedCount};
  }

  function estimateAreaScore(board,n,komi){
    let bSt=0,wSt=0,bTerr=0,wTerr=0;
    for(let r=0;r<n;r++) for(let c=0;c<n;c++){ if(board[r][c]===BLACK)bSt++; else if(board[r][c]===WHITE)wSt++; }
    const visited=Array.from({length:n},()=>Array(n).fill(false));
    for(let r=0;r<n;r++) for(let c=0;c<n;c++){
      if(board[r][c]!==0 || visited[r][c]) continue;
      const stack=[[r,c]]; visited[r][c]=true; const region=[]; const borders=new Set();
      while(stack.length){
        const [rr,cc]=stack.pop(); region.push([rr,cc]);
        for(const [nr,nc] of neighbors(n,rr,cc)){
          const v=board[nr][nc];
          if(v===0 && !visited[nr][nc]){ visited[nr][nc]=true; stack.push([nr,nc]); }
          else if(v!==0) borders.add(v);
        }
      }
      if(borders.size===1){ const owner=borders.has(BLACK)?BLACK:WHITE; if(owner===BLACK) bTerr+=region.length; else wTerr+=region.length; }
    }
    const bArea=bSt+bTerr; const wArea=wSt+wTerr+komi; const diff=bArea - wArea;
    return {bSt,wSt,bTerr,wTerr,bArea,wArea,diff};
  }

  function sgfCoord(r,c){
    const toLetter=n=>String.fromCharCode('a'.charCodeAt(0)+n);
    return toLetter(c)+toLetter(r);
  }
  function toSGF(moves,n,handicapCount,komi,result){
    let body = `(;GM[1]FF[4]SZ[${n}]KM[${komi}]`;
    if(handicapCount>0) body += `HA[${handicapCount}]`;
    if(result) body += `RE[${String(result).replace(/]/g,'\\]')}]`;
    body += ';';
    for(const m of moves){
      if(m.pass) body += `${m.color===BLACK?'B':'W'}[tt]`;
      else body += `${m.color===BLACK?'B':'W'}[${sgfCoord(m.r,m.c)}]`;
    }
    return body + ')';
  }

  // ----- State -----
  let history = [];
  let redo = [];

  function defaultKomi(n){ return n===19?6.5:n===13?5.5:2.5; }

  function initHandicapOptions(){
    handicapSel.innerHTML='';
    for(let i=0;i<=9;i++){
      const opt=document.createElement('option'); opt.value=String(i); opt.textContent=String(i); handicapSel.appendChild(opt);
    }
  }

  function setStatus(msg){ statusEl.textContent = msg || ''; }

  function newGame(){
    size = parseInt(sizeSel.value,10);
    komi = parseFloat(komiInp.value);
    handicap = parseInt(handicapSel.value,10);
    sizeLabel.textContent = `${size}×${size}`;

    let board = emptyBoard(size);
    let toMove = BLACK;
    let captures = {[BLACK]:0,[WHITE]:0};
    let moves = [];
    if(handicap>0){
      board = placeHandicap(board,size,handicap);
      toMove = WHITE; // after handicap
      const pts = starPoints(size).slice(0, Math.min(handicap,9));
      for(const [r,c] of pts) moves.push({color:BLACK,r,c});
    }
    history = [{
      board, toMove, captures, lastMove:null, prevBoardStr:null,
      passStreak:0, moveNumber:0, moves
    }];
    redo = [];
    render();
    setStatus('New game ready.');
  }

  function playAt(r,c){
    const curr = history[history.length-1];
    const result = attemptPlay(curr.board,size,r,c,curr.toMove,curr.prevBoardStr);
    if(!result.ok){ setStatus(`Illegal move: ${result.reason}`); return; }
    const newCaps = {...curr.captures};
    if(result.captured>0) newCaps[curr.toMove] = (newCaps[curr.toMove]||0) + result.captured;

    const next = {
      board: result.board,
      toMove: opposite(curr.toMove),
      captures: newCaps,
      lastMove: {r,c,color:curr.toMove},
      prevBoardStr: serializeBoard(curr.board),
      passStreak: 0,
      moveNumber: curr.moveNumber+1,
      moves: [...curr.moves, {color:curr.toMove,r,c}]
    };
    history.push(next); redo=[]; render(); setStatus('');
  }

  function passMove(){
    const curr = history[history.length-1];
    const next = {
      ...curr,
      toMove: opposite(curr.toMove),
      lastMove: {pass:true,color:curr.toMove},
      prevBoardStr: serializeBoard(curr.board),
      passStreak: curr.passStreak+1,
      moveNumber: curr.moveNumber+1,
      moves: [...curr.moves, {color:curr.toMove, pass:true}]
    };
    history.push(next); redo=[]; render();
    if(next.passStreak>=2){ setStatus('Both players passed. You may review score below.'); }
  }

  function resign(){
    const loser = history[history.length-1].toMove===BLACK? 'Black':'White';
    alert(`${loser} resigns. Game over.`);
  }

  function doUndo(){ if(history.length>1){ redo.unshift(history.pop()); render(); } }
  function doRedo(){ if(redo.length>0){ history.push(redo.shift()); render(); } }

  function downloadSGF(){
    const s = toSGF(history[history.length-1].moves, size, handicap, komi, '');
    const blob = new Blob([s], {type:'application/x-go-sgf'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download=`go_${size}.sgf`; a.click(); URL.revokeObjectURL(url);
  }

  // ----- Rendering -----
  function clearSVG(){ while(boardSVG.firstChild) boardSVG.removeChild(boardSVG.firstChild); }

  function renderGrid(){
    const line = (x1,y1,x2,y2)=>{ const el=document.createElementNS('http://www.w3.org/2000/svg','line'); el.setAttribute('x1',x1); el.setAttribute('y1',y1); el.setAttribute('x2',x2); el.setAttribute('y2',y2); el.setAttribute('stroke','#222'); el.setAttribute('stroke-width','1.5'); boardSVG.appendChild(el); };
    const boardPx = (size-1)*cellPx + origin*2;
    boardSVG.setAttribute('width', boardPx);
    boardSVG.setAttribute('height', boardPx);

    // grid lines
    for(let i=0;i<size;i++){
      const y = origin + i*cellPx; line(origin, y, origin+(size-1)*cellPx, y);
      const x = origin + i*cellPx; line(x, origin, x, origin+(size-1)*cellPx);
    }

    // star points
    for(const [r,c] of starPoints(size)){
      const cx = origin + c*cellPx; const cy = origin + r*cellPx;
      const dot=document.createElementNS('http://www.w3.org/2000/svg','circle');
      dot.setAttribute('cx',cx); dot.setAttribute('cy',cy); dot.setAttribute('r',3); dot.setAttribute('fill','#222');
      boardSVG.appendChild(dot);
    }
  }

  function renderStones(){
    const st = history[history.length-1];
    const board = st.board;
    for(let r=0;r<size;r++) for(let c=0;c<size;c++){
      const v = board[r][c]; if(!v) continue;
      const cx = origin + c*cellPx; const cy = origin + r*cellPx;
      const g=document.createElementNS('http://www.w3.org/2000/svg','g');
      const stone=document.createElementNS('http://www.w3.org/2000/svg','circle');
      stone.setAttribute('cx',cx); stone.setAttribute('cy',cy); stone.setAttribute('r',15);
      stone.setAttribute('fill', v===BLACK? '#111':'#eee'); stone.setAttribute('stroke','#000'); stone.setAttribute('stroke-width','1');
      g.appendChild(stone);
      if(st.lastMove && st.lastMove.r===r && st.lastMove.c===c){
        const mark=document.createElementNS('http://www.w3.org/2000/svg','circle');
        mark.setAttribute('cx',cx); mark.setAttribute('cy',cy); mark.setAttribute('r',6);
        mark.setAttribute('fill', v===BLACK?'#eee':'#111'); mark.setAttribute('opacity','0.9');
        g.appendChild(mark);
      }
      boardSVG.appendChild(g);
    }
  }

  function onBoardClick(evt){
    const rect = boardSVG.getBoundingClientRect();
    const x = evt.clientX - rect.left - origin;
    const y = evt.clientY - rect.top - origin;
    const c = Math.round(x / cellPx);
    const r = Math.round(y / cellPx);
    if(r>=0 && r<size && c>=0 && c<size) playAt(r,c);
  }

  function render(){
    clearSVG(); renderGrid(); renderStones();
    boardSVG.onclick = onBoardClick;
    const st = history[history.length-1];
    turnLabel.textContent = st.toMove===BLACK? 'Black':'White';
    const sc = estimateAreaScore(st.board,size,komi);
    scoreGrid.innerHTML = `
      <div class="small">To move</div><div>${st.toMove===BLACK?'Black':'White'}</div>
      <div class="small">Black captures</div><div>${st.captures[BLACK]||0}</div>
      <div class="small">White captures</div><div>${st.captures[WHITE]||0}</div>
      <div class="small">Moves played</div><div>${st.moveNumber}</div>
      <div class="small">Black stones</div><div>${sc.bSt}</div>
      <div class="small">White stones</div><div>${sc.wSt}</div>
      <div class="small">Black territory</div><div>${sc.bTerr}</div>
      <div class="small">White territory</div><div>${sc.wTerr}</div>
      <div class="small">Komi</div><div>${komi}</div>
      <div><b>Black area</b></div><div><b>${sc.bArea}</b></div>
      <div><b>White area</b></div><div><b>${sc.wArea.toFixed(1)}</b></div>
      <div>${sc.diff>0? 'Black leads by':'White leads by'}</div><div>${Math.abs(sc.diff).toFixed(1)}</div>
    `;
  }

  // ----- Events -----
  initHandicapOptions();
  sizeSel.addEventListener('change', () => {
    // reset komi sensible default
    komiInp.value = String(defaultKomi(parseInt(sizeSel.value,10)));
  });
  newBtn.addEventListener('click', newGame);
  undoBtn.addEventListener('click', doUndo);
  redoBtn.addEventListener('click', doRedo);
  passBtn.addEventListener('click', passMove);
  resignBtn.addEventListener('click', resign);
  exportBtn.addEventListener('click', downloadSGF);

  window.addEventListener('keydown', (e) => {
    if(e.key==='u' || e.key==='U') doUndo();
    else if(e.key==='r' || e.key==='R') doRedo();
    else if(e.key==='p' || e.key==='P') passMove();
  });

  // First load
  newGame();
})();
</script>
</body>
</html>
